<!DOCTYPE html>
<html style="font-size:625%">
<head>
  <meta charset="utf-8">
  <meta name="keywords" content="livelybone, plugins, vue, vuejs, react, js, javascript, node, php">
  <meta name="author" content="livelybone(2631541504@qq.com)">
  <title>HTTP vs RPC -- livelybone</title>
  <link rel="shortcut icon" href="../../logo.png">
  <link rel="shortcut icon" href="../../logo.svg" type="image/svg+xml">
  <link rel="stylesheet" href="../../common/css/common.css">
  <link rel="stylesheet" href="../../common/css/highlight.min.css">
  <script src="../../common/js/common.js"></script>
  <style type="text/css">
  .btn-group {
    margin: 0 0 -.15rem;
  }

  button {
    /*margin: 0 .15rem .15rem 0;*/
  }

  @media (orientation: portrait) {
    button {
      width: 100%;
    }
  }

  img {
    max-width: 100%;
    vertical-align: middle;
  }

  textarea {
    width: 2rem;
    height: 1rem;
    padding: .1rem;
  }
  </style>
</head>
<body>
<h1 class="root-h1">动态规划 背包问题</h1>
<section class="app">
  <h2 id="简介" class="root-h">简介</h2>
  <p class="root-content-wrap">
    Vue 对数据之间的依赖的处理很方便：<br>
    使用 computed 添加的属性，能自动根据依赖属性的变化更新属性值，并保留缓存；<br>
    使用 watch，能监听属性值的变化。<br><br>
    本文目的在于探讨 computed 和 watch 的内部实现逻辑，帮助我们更好的理解这种响应式数据的开发模式<br>
    以下为我的简化版的实现(未借鉴 Vue 源码，因为我还没看(TOT))：
  </p>

  <h2 id="OSI模型" class="root-h">OSI模型</h2>
  <div class="example-wrap">
    <p class="root-desc">
      OSI(Open System Interconnection Reference Modal)，是一个视图使各种计算机在世界范围内互连为网络的标准框架
    </p>
    <p class="root-module-title">物理层</p>
    <p class="root-module-title">数据链路层</p>
    <p class="root-module-title">网络层</p>
    <p class="root-module-title">传输层</p>
    <p class="root-module-title">会话层</p>
    <p class="root-module-title">表达层</p>
    <p class="root-module-title">应用层</p>
  </div>
</section>

<script src="../../common/js/highlight.min.js"></script>
<script type="text/javascript" id="code">
/*CATALOGUE: 简介, 示例, Code*/
</script>
</body>
</html>
